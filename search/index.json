[{"content":"Akka是什么？ Build powerful reactive, concurrent, and distributed applications more easily\n前言 Akka是\n","date":"2023-06-26T14:28:00Z","permalink":"https://wuyoudexiao.github.io/p/akka-1/","title":"初识Akka"},{"content":"MQ在设计功能时候应该考虑什么？ 前言 No Silver Bullet—Essence and Accidents of Software Engineering\n没有银弹，指的是不存在万能的，解决所有问题的方案。在设计一个方案时候，需要对功能、能力的优先级进行区分，优先保证最重要的能力。\nMQ的能力优先级 1.生产者发送消息正常 MQ核心能力之一就是削峰填谷，如果生产者的消息发送不正常，那么显然违背了使用MQ的初衷，当然为了保护整个MQ系统的可用性，有时限流生产者的行为是可以接受的。\n2.消息持久化不丢失 消息持久化后丢失或者没有成功持久化，带来的结果是消息的丢失，通常需要结合业务日志做排查才能将这部分丢失数据重新找回，甚至可能就是无法找回带来实实在在的损失。\n3.消息消费不丢失 这里的消费不丢失是指的消费位点没有被跳过，每一条消息都被消费者成功消费至少一次，如果出现消费丢失情况，且没有能够及时发现会对业务造成影响。\n4.顺序消息的顺序性 顺序消息的顺序性通常是为了保证业务的正常执行，如果顺序打乱通常会造成业务执行的阻塞，但是通常容易发现，容易解决。\n5.消息低延迟 MQ的延迟不是优先考虑的因素，如果需要超级低延迟，通常使用RPC调用方式，但是MQ通常也需要把延迟压到ms级\n6.消息不重复 为了能够保证1-4，消息不重复通常是最容易被放弃的能力，也是大部分的MQ都要求下游消费者做好幂等的原因。\n7.消息可观测 ","date":"2023-06-20T14:28:00Z","permalink":"https://wuyoudexiao.github.io/p/rmq-design/","title":"MQ在设计功能时候应该考虑什么？"},{"content":"Netty 与 零拷贝 前言 在学习RocketMQ的过程中发现其零拷贝功能并不推荐开启，但是Kafka的零拷贝能力为其提供了较大的吞吐能力，为什么在RocketMQ中却不推荐开启呢？对比发现RocketMQ使用了Netty网络库的零拷贝，而Kafka的零拷贝是自己实现的，通过学习Netty的线程池和网络模型，可以从中发现问题。\n","date":"2023-06-05T14:28:00Z","permalink":"https://wuyoudexiao.github.io/p/rmq-netty/","title":"Netty 与 零拷贝"},{"content":"1. KEY-VALUE 例子：Redis，Memocashed， etcd\n特征：\n数据本身存储的结构类似于Map\u0026lt;String,Object\u0026gt;或者python的字典 有一组KEY，且每一个KEY都是唯一的，指向某个值 Redis等数据库数据存储于内存中 优点：\n内存io远远快于硬盘io （通常单次操作耗时在亚微秒级） 缺点：\n内存为易丢失性存储 无法进行join等操作 使用：\n多数时候作为缓存的角色来降低数据io的延迟 也可以用来做消息队列、发布订阅等需求 2.WIDE COLUMN 例子：Cassandra， Hbase\n特征：\n可以看作给KEY-VALUE型数据库的增加了一个维度 有一组KEY，且每一个KEY都是唯一的，一个KEY可以对应多个列族，每个族群对应一列有序的数据 优点：\n可以处理非结构化的数据 可以执行数据的聚合操作 采用于SQL类似的CQL进行查询，学习成本不高 去中心化存储，支持横向扩展 缺点：\n无法进行join等操作 使用：\n多数用字啊经常写却不经常读取的场景里 处理时间相关数据较优秀 3.DOCUMENT 例子：MongoDB， FireStore\n特征：\n需要建立docuemnt，每个文档都是KEY-VALUE数据的容器 非结构化，不需要Schema docuemnts聚合成为一个Collection，Collection中的字段可以 被索引，docuemnt可以具有上下层次关系 优点：\n一定程度上可以对关系型数据进行建模和读写 读数据会很快 缺点：\n无法进行join等操作 写数据较为复杂 使用：\n已经较为通用，可应用于内容管理，游戏开发等场景 4.RELATIONAL 例子：Mysql，SQLServer\n特征：\n采用SQL语句（structured query language） 每个表存储单一的类型，大部分时候都会有唯一在主键 通过外键将不同的表中的数据联合起来 数据以最小单元，按照特定的格式统一存储 优点：\nACID 保证事务的有效性 join查询 缺点：\n需要首先确定Schema 难以规模化 5.GRAPH 例子：neo4j\n特征：\n数据的关系被视为图的边 优点：\n多对多的关系建立简单 大数据量时候性能相较于SQL更好 用处：\n在存储关系为核心的数据时 6.SEARCH 例子：elastic\n特征：\n对文本进行全文索引 优点：\n文本全局搜索速度快 用处：\n搜索 ","date":"2023-05-01T12:00:00Z","permalink":"https://wuyoudexiao.github.io/p/db-classification/","title":"数据库类型"},{"content":"接雨水 今日做LC42的接雨水，逐步优化代码，写一篇博客记录一下。\n暴力解 动态规划解 动态规划解的思路是，将每一列的雨水看为收集的对象，可以发现每一列的雨水取决于这一列左边最高的柱子和右边最高的柱子中的较矮的一个，所以我们可以利用dp数组记录每一列左边最高的柱子和右边最高的柱子，再将每一列雨水通过min(left[i], right[i]) - arr[i]进行收集。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main func maxWater(arr []int) int64 { // write code here left := make([]int, len(arr)) right := make([]int, len(arr)) left[0] = 0 right[len(right)-1] = 0 for i := 1; i \u0026lt; len(arr); i++ { left[i] = max(left[i-1], arr[i-1]) } for i := len(right) - 2; i \u0026gt;= 0; i-- { right[i] = max(right[i+1], arr[i+1]) } res := 0 for i := 0; i \u0026lt; len(arr); i++ { w := min(left[i], right[i]) - arr[i] if w \u0026gt; 0 { res += w } } return int64(res) } func max(a, b int) int { if a \u0026gt; b { return a } else { return b } } func min(a, b int) int { if a \u0026gt; b { return b } else { return a } } 双指针 双指针方法的优点在于节约了dp数组的存储空间，空间复杂度O(1)且只遍历一次，相比dp多次要快，其核心思路是通过记录左右的最大值作为其边界，并控制左右边界向内收缩\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main func maxWater(arr []int) int64 { // write code here if len(arr) \u0026lt;= 2 { return 0 } left, right := 0, len(arr)-1 maxL, maxR := arr[left], arr[right] res := 0 for left \u0026lt; right { maxL = max(maxL, arr[left]) maxR = max(maxR, arr[right]) if maxL \u0026lt;= maxR { left++ if maxL-arr[left] \u0026gt; 0 { res += maxL - arr[left] } } else { right-- if maxR-arr[right] \u0026gt; 0 { res += maxR - arr[right] } } } return int64(res) } func max(a, b int) int { if a \u0026gt; b { return a } else { return b } } ","date":"2023-03-19T14:28:00Z","image":"https://wuyoudexiao.github.io/p/lc-42/cover_hu09a7a297975f66e21a18a24998cdff15_6939_120x120_fill_box_smart1_3.png","permalink":"https://wuyoudexiao.github.io/p/lc-42/","title":"LC42 接雨水"},{"content":"数组中的第K个最大元素 今日做LC215的排序，深感自己堆排与快排的基本功不扎实，写一篇博客记录一下。\n堆排解 如果是笔试题目，那么可以直接实现go的heap接口，就能使用堆排序了，但是面试显然不能这么做，还是需要搞清楚堆排序的原理。这一题的堆排解的思路大致分为三个部分：\n构建最大堆 从最大堆中Pop 个数 官方库实现 思路有了，最关键的就是如何实现堆排序，我们可以看一下go官方库container/heap\n官方库中首先定义了一个接口，如果我们平时需要用堆可以实现该接口\n1 2 3 4 5 type Interface interface { sort.Interface Push(x any) // add x as element Len() Pop() any // remove and return element Len() - 1. } 初始化函数，用来构造一个堆，由于我们只需要关注非叶子节点，所以这里的循环只需要i := n/2 - 1，然后我们可以看到关键的函数是down下面来看如何是实现\n1 2 3 4 5 6 7 func Init(h Interface) { // heapify n := h.Len() for i := n/2 - 1; i \u0026gt;= 0; i-- { down(h, i, n) } } 发现j1 := 2*i + 1是找左孩子节点，同理j2就是右孩子节点，通过比较找出父节点、左右孩子节点中最小的一个并与父节点交换，依次是一个从上至下的下沉过程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func down(h Interface, i0, n int) bool { i := i0 for { j1 := 2*i + 1 if j1 \u0026gt;= n || j1 \u0026lt; 0 { // j1 \u0026lt; 0 after int overflow break } j := j1 // left child if j2 := j1 + 1; j2 \u0026lt; n \u0026amp;\u0026amp; h.Less(j2, j1) { j = j2 // = 2*i + 2 // right child } if !h.Less(j, i) { break } h.Swap(i, j) i = j } return i \u0026gt; i0 } 构造之后再来看看如何加入节点，发现其中关键是up函数，看看其实现，其与down函数不同的是，这是自下而上，从叶子节点逐渐与父节点比较，最终到root结束，是一个上浮的过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func Push(h Interface, x any) { h.Push(x) up(h, h.Len()-1) } func up(h Interface, j int) { for { i := (j - 1) / 2 // parent if i == j || !h.Less(j, i) { break } h.Swap(i, j) j = i } } 最后再来看看如何pop最小值，将root与最后一个叶子交换，并让叶子下沉\n1 2 3 4 5 6 func Pop(h Interface) any { n := h.Len() - 1 h.Swap(0, n) down(h, 0, n) return h.Pop() } 官方使用例 最后再看看go官方给的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // Copyright 2012 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // This example demonstrates an integer heap built using the heap interface. package heap_test import ( \u0026#34;container/heap\u0026#34; \u0026#34;fmt\u0026#34; ) // An IntHeap is a min-heap of ints. type IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] \u0026lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x any) { // Push and Pop use pointer receivers because they modify the slice\u0026#39;s length, // not just its contents. *h = append(*h, x.(int)) } func (h *IntHeap) Pop() any { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } // This example inserts several ints into an IntHeap, checks the minimum, // and removes them in order of priority. func Example_intHeap() { h := \u0026amp;IntHeap{2, 1, 5} heap.Init(h) heap.Push(h, 3) fmt.Printf(\u0026#34;minimum: %d\\n\u0026#34;, (*h)[0]) for h.Len() \u0026gt; 0 { fmt.Printf(\u0026#34;%d \u0026#34;, heap.Pop(h)) } // Output: // minimum: 1 // 1 2 3 5 } 题目解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func findKthLargest(nums []int, k int) int { size := len(nums) build(nums, size) for i:=0;i\u0026lt;k-1;i++{ nums[0],nums[size-1]=nums[size-1],nums[0] size-- fetch(nums, size, 0) } return nums[0] } func build(nums []int,size int){ for i:=size/2;i\u0026gt;=0;i--{ fetch(nums, size, i) } } func fetch(nums[]int,size int,i int){ l,r := i*2+1,i*2+2 choose := i if l\u0026lt;size \u0026amp;\u0026amp; nums[l] \u0026gt; nums[choose]{ choose = l } if r\u0026lt;size \u0026amp;\u0026amp; nums[r] \u0026gt; nums[choose]{ choose = r } if choose != i{ nums[choose],nums[i] = nums[i],nums[choose] fetch(nums, size , choose) } } 快排解 快排解是利用快排的分治思路，每次分割 \u0026lt;p 和 \u0026gt;p两个部分，但是我们需要的第k个数只在其中的一个区间内，而另一个区间是否有序我们并不关心，所以可以只选择一个部分继续排序，相较于原本的快排，不完整的快排的时间复杂度为O(n)，上一篇博客详细写了快排的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import \u0026#34;math/rand\u0026#34; /** * * @param a int整型一维数组 * @param n int整型 * @param K int整型 * @return int整型 */ func findKth( a []int , n int , K int ) int { // write code here rand.Seed(2) return quick(a,n,K) } func quick(a []int, n int, K int) int { t := rand.Intn(n) a[0], a[t] = a[t], a[0] lptr, rptr := 1, n-1 for lptr \u0026lt;= rptr { if a[lptr] \u0026gt; a[0] { a[lptr], a[rptr] = a[rptr], a[lptr] rptr-- } else { lptr++ } } if n-lptr+1 == K { return a[0] } else if K \u0026lt;= n-lptr { return quick(a[lptr:], n-lptr, K) } else { a[0], a[lptr-1] = a[lptr-1], a[0] return quick(a[:lptr-1], lptr-1, K-n+lptr-1) } } ","date":"2023-03-15T14:28:00Z","image":"https://wuyoudexiao.github.io/p/lc-215/cover_hu10bbab85bb1797fea124506da3813e2c_76036_120x120_fill_box_smart1_3.png","permalink":"https://wuyoudexiao.github.io/p/lc-215/","title":"LC215 数组中的第K个最大元素"},{"content":"快排为什么会超时 今日做LC912的排序，经历了惨痛的失败，信心满满的写出来一个快排，结果毫不留情超时，以为是自己的排序写的不多，核对再三发现样例中有超长逆序样例。\n原解 原本用的就是一个简单的快速排序，用最左作为基准点，但是这题目坑就在这了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 func sortArray(nums []int) []int { quickSort(nums) return nums } func quickSort(nums []int){ if len(nums)\u0026lt;=1{ return } i,j := 0,len(nums)-1 order := true for i\u0026lt;j{ if order{ if nums[i]\u0026lt;nums[j]{ j-- }else{ nums[i],nums[j]=nums[j],nums[i] order = !order i++ } }else{ if nums[i]\u0026lt;nums[j]{ i++ }else{ nums[i],nums[j]=nums[j],nums[i] order = !order j-- } } } quickSort(nums[0:i]) if i \u0026lt;len(nums)-1{ quickSort(nums[i+1:]) } } 快排优化的方式 快排优化的方式常见的有：\n当数列近乎有序的时，由于每次选取的都是第一个数，所以造成数列分割的极其不等，此时快排蜕化成O (n * n)的算法， 此时只要随机选取基准点即可 -当数列中包含大量的重复元素的时候，这一版的代码也会造成\u0026quot;分割不等“的问题，此时需要将重复元素均匀的分散的自数列旁\n使用三路快排 尝试优化 首先观察发现超时样例确实是因为数列近乎有序，所以首先加上随机取点，代码果然AC了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 func sortArray(nums []int) []int { rand.Seed(2) quickSort(nums,0,len(nums)) return nums } func quickSort(nums []int, l,r int){ if r-l\u0026lt;=1{ return } //随机选择一个点与最左进行交换 point := rand.Intn(r-l)+l nums[point],nums[l] =nums[l],nums[point] i,j := l,r-1 order := true for i\u0026lt;j{ if order{ if nums[i]\u0026lt;nums[j]{ j-- }else{ nums[i],nums[j]=nums[j],nums[i] order = !order i++ } }else{ if nums[i]\u0026lt;nums[j]{ i++ }else{ nums[i],nums[j]=nums[j],nums[i] order = !order j-- } } } quickSort(nums,l,i) if i \u0026lt;len(nums)-1{ quickSort(nums,i+1,r) } } 三路快排 三路快排考虑了大量重复元素的情况，可以参考LC75. 颜色分类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func sortArray(nums []int) []int { rand.Seed(2) quickSort(nums,0,len(nums)) return nums } func quickSort(nums []int, l,r int){ if r-l\u0026lt;=1{ return } point := rand.Intn(r-l)+l nums[point],nums[l] =nums[l],nums[point] lt,gt:=l,r i:=l+1 for i\u0026lt;gt{ if nums[i] == nums[l]{ i++ }else if nums[i] \u0026lt; nums[l]{ nums[lt+1],nums[i]=nums[i],nums[lt+1] lt++ i++ }else{ nums[gt-1],nums[i]=nums[i],nums[gt-1] gt-- } } nums[l],nums[lt]=nums[lt],nums[l] quickSort(nums,l,lt) quickSort(nums,gt,r) } ","date":"2023-03-13T14:28:00Z","image":"https://wuyoudexiao.github.io/p/lc-912/cover_hua802d2f8794e046999cfc52dd0305f98_17838_120x120_fill_box_smart1_3.png","permalink":"https://wuyoudexiao.github.io/p/lc-912/","title":"LC912 数组排序"},{"content":"BM98 螺旋矩阵 https://www.nowcoder.com/practice/7edf70f2d29c4b599693dc3aaeea1d31\n描述 给定一个mxn大小的矩阵（m行，n列），按螺旋的顺序返回矩阵中的所有元素。\n要求： 空间复杂度 O(nm) ，时间复杂度 O(nm)\n思路 按照圈层遍历矩阵 通过左上角坐标与右下角坐标确认便利圈层 边界情况：构不成圈，一行或者一列或者一个节点的特殊处理 特殊情况：空矩阵 AC代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package main /** * * @param matrix int整型二维数组 * @return int整型一维数组 */ func spiralOrder( matrix [][]int ) []int { // write code here m := len(matrix)-1 if m \u0026lt;= -1{ return []int{} } n := len(matrix[0])-1 s := 0 t := 0 res := make([]int,0,m*n) for s\u0026lt;=m \u0026amp;\u0026amp; t\u0026lt;=n{ if s == m{ for i:=t;i\u0026lt;=n;i++{ res = append(res, matrix[s][i]) } return res } if n == t { for i:=s;i\u0026lt;=m;i++{ res = append(res,matrix[i][n]) } return res } for i:=t;i\u0026lt;n;i++{ res = append(res, matrix[s][i]) } for i:=s;i\u0026lt;m;i++{ res = append(res, matrix[i][n]) } for i:=n;i\u0026gt;t;i--{ res = append(res,matrix[m][i]) } for i:=m;i\u0026gt;s;i--{ res = append(res,matrix[i][t]) } s += 1 t += 1 m -= 1 n -= 1 } return res } ","date":"2023-03-01T14:28:00Z","image":"https://wuyoudexiao.github.io/p/nc-bm98/cover_hue8cdcc49aa4266c00863ddf68c8459ee_20472_120x120_fill_box_smart1_3.png","permalink":"https://wuyoudexiao.github.io/p/nc-bm98/","title":"BM98 螺旋矩阵"},{"content":"问题复盘 责任人 不是我搞炸的，只是负责善后\n问题表现和原因 问题表现：Elasticsearch集群全部掉线，科研大数据赋能平台搜索功能不可用，Kibana页面打不开。\n原因：原153机器中的Elasticsearch部署方式为压缩包安装，存在机器重启后服务掉线隐患，因此需要重新部署为自启动服务。重新安装后，153机器中的新节点无法接入83机器中的集群，尝试重启83中的主节点后出现ES集群全部不可用的情况，尝试回退机器系统后153机器的原服务不能自动恢复，导致83机器中的集群无法正常工作。\n报错的解决：ES需要超过半数的集群启动才能启动，否则无法选举出主节点，配置中的init master在已经运行后再启动的集群上不生效。所以减少节点数量最好是逐渐减少。\n各时间节点（操作和恢复步骤及线上问题表现） 2月27号 尝试在153机器中部署新节点。 2月28号 153机器中的节点无法加入集群 16点尝试重启83机器中的ES服务，Elasticsearch服务掉线，科研大数据赋能平台搜索功能不可用。 17点开始回退机器系统。 3月1号 9点重启153机器中的旧服务。 10点30在153机器中部署新的自启动服务，并成功接入集群，科研大数据赋能平台搜索功能恢复正常。 后续避免措施 ES配置注意事项： 新建节点服务安装完不要启动！不要启动！启动会产生新的cluster uuid，与已有集群不一致，导致无法加入集群。如不慎启动，关闭服务后，删除node文件夹 新节点加入集群只需配置新节点的配置文件即可，证书密钥复制即可，重点配置elasticsearch.yml文件。 流程事项： 在不确定是否会对主服务产生影响的情况禁止操作。禁止重启83机器中的服务。 提前规划好操作方案，并整理成技术文档交由主管老师审核，审核通过后执行。 ","date":"2023-03-01T12:00:00Z","image":"https://wuyoudexiao.github.io/p/issue-es/cover_hu18cfcb466ca25429b480c33e8d5461b4_490997_120x120_fill_box_smart1_3.png","permalink":"https://wuyoudexiao.github.io/p/issue-es/","title":"ES集群的崩溃"},{"content":"Tars学习记录 参考官方文档 https://doc.tarsyun.com/#/default-index 如果本文内容与官方文档出现偏差以官方文档为准\nSpringBoot 客户端 调用方法 1.引入*.tars文件 tar文件放于resources文件夹下面\n1 2 3 4 5 6 7 8 module graph { interface Person{ string findPersonById(string id); string findShortPathByNumber(string type,string number1,string number2); string getLinkByName(string number,string type); }; }; 2.修改pom.xml文件 pom文件中添加依赖与打包插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!--tars--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.tencent.tars\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tars-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.2\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;jar\u0026lt;/type\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 打包插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;com.tencent.tars\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tars-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;tars2JavaConfig\u0026gt; \u0026lt;!-- tars文件位置 --\u0026gt; \u0026lt;tarsFiles\u0026gt; \u0026lt;tarsFile\u0026gt;${basedir}/src/main/resources/sda.tars\u0026lt;/tarsFile\u0026gt; \u0026lt;/tarsFiles\u0026gt; \u0026lt;!-- 源文件编码 --\u0026gt; \u0026lt;tarsFileCharset\u0026gt;UTF-8\u0026lt;/tarsFileCharset\u0026gt; \u0026lt;!-- 生成代码，PS：客户端调用，这里需要设置为false --\u0026gt; \u0026lt;servant\u0026gt;false\u0026lt;/servant\u0026gt; \u0026lt;!-- 生成源代码编码 --\u0026gt; \u0026lt;charset\u0026gt;UTF-8\u0026lt;/charset\u0026gt; \u0026lt;!-- 生成的源代码目录 --\u0026gt; \u0026lt;srcPath\u0026gt;${basedir}/src/main/java/\u0026lt;/srcPath\u0026gt; \u0026lt;!-- 生成源代码包前缀 --\u0026gt; \u0026lt;packagePrefixName\u0026gt;cn.edu.seu.matrix.tars\u0026lt;/packagePrefixName\u0026gt; \u0026lt;/tars2JavaConfig\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; 3.执行mvn tars:tars2java 生成文件 mvn执行后在定义的目录里生成文件\n4.调用 在@service或者@Controller类中添加\n1 2 3 4 private CommunicatorConfig cfg = new CommunicatorConfig(); private Communicator communicator = CommunicatorFactory.getInstance().getCommunicator(cfg); private String ip_tars=\u0026#34;SERVER_IP\u0026#34;; // 在tars上运行的服务用 173 的，其余用机器地址 private final String tars_app_name=\u0026#34;SERVER_NAME\u0026#34;; // 举例 SciDataAnalysis.SocialNetwork 然后生成代理，调用方法\n1 2 PersonPrx proxy = communicator.stringToProxy(PersonPrx.class, tars_app_name + \u0026#34;.PersonObj@tcp -h \u0026#34; + ip_tars + \u0026#34; -t 60000 -p 27430 -e 0\u0026#34;); proxy.findPersonById(number) 服务端 提供服务方法 1. 写tars文件 tars文件的编写请参考官方文档\n参考官方文档 https://doc.tarsyun.com/#/base/tars-protocol.md 如果本文内容与官方文档出现偏差以官方文档为准\n2.修改pom.xml文件 pom文件中添加依赖与打包插件\n1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.tencent.tars\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tars-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.2\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;jar\u0026lt;/type\u0026gt; \u0026lt;/dependency\u0026gt; 打包插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;com.tencent.tars\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tars-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;tars2JavaConfig\u0026gt; \u0026lt;!-- tars文件位置 --\u0026gt; \u0026lt;tarsFiles\u0026gt; \u0026lt;tarsFile\u0026gt;${basedir}/src/main/resources/socialNetwork.tars\u0026lt;/tarsFile\u0026gt; \u0026lt;/tarsFiles\u0026gt; \u0026lt;!-- 源文件编码 --\u0026gt; \u0026lt;tarsFileCharset\u0026gt;UTF-8\u0026lt;/tarsFileCharset\u0026gt; \u0026lt;!-- 生成服务端代码 --\u0026gt; \u0026lt;servant\u0026gt;true\u0026lt;/servant\u0026gt; \u0026lt;!-- 生成源代码编码 --\u0026gt; \u0026lt;charset\u0026gt;UTF-8\u0026lt;/charset\u0026gt; \u0026lt;!-- 生成的源代码目录 --\u0026gt; \u0026lt;srcPath\u0026gt;${basedir}/src/main/java\u0026lt;/srcPath\u0026gt; \u0026lt;!-- 生成源代码包前缀 --\u0026gt; \u0026lt;packagePrefixName\u0026gt;cn.edu.seu.socialNetwork\u0026lt;/packagePrefixName\u0026gt; \u0026lt;/tars2JavaConfig\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; 3.执行mvn tars:tars2java 生成文件 mvn执行后在定义的目录里生成文件,其中Servant接口类是自动生成的\n4.实现 将Servant接口类实现一下 其中PersonObj与页面上的定义一致\n1 2 3 @TarsServant(\u0026#34;PersonObj\u0026#34;) public class PersonObj implements PersonServant { } 类中需要@Override所有的 方法\n5.定义服务 6.打包上传 基于Docker容器的TARS JAVA环境搭建 安装前准备 本教程需要预先安装Docker环境，所使用的IDE为IntelliJ IDEA。所有安装都基于Windows环境下。文中涉及到的目录均以 C:/User/xxx/ 写法表示\n获取Docker镜像 拉取最新的TARS容器（Java版）：\n1 docker pull tarscloud/tars:java 如果需要不同JDK版本的容器，可以基于Dockerfile来修改和构建自己的容器镜像（install.sh内容也要做相应修改）。由于该镜像未安装mysql，故还需要安装mysql镜像，以5.7版本为例。\n1 docker pull mysql:5.7 快速上手例程 本教程使用代码仓库中的 quickstart-server 和 quickerstart-client 例程作为搭建代码，可以先下载到本地使用IDEA打开。\n开发方式 使用docker镜像进行Tars相关的开发非常方便，例如可以把项目放置在某个本地目录下，如\nC:/Users/xxx/tars_data\n，再将该目录挂载到镜像的\n/data\n目录，这样就能在本地使用编辑器或IDE对项目文件进行开发。 如果需要进入Tars环境进行编译或测试，可以使用命令\ndocker exec\n进入容器内部查看。\n服务端配置 启动容器 首先执行下面的命令来启动TARS（Windows命令行不支持 \\ 命令换行），注意需要先在 C:/User/xxx/ 目录下新建目录 mysql_data 和 tars_data 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 docker run -d --name mysql \\ -e MYSQL_ROOT_PASSWORD=password \\ -p 3306:3306 \\ -v C:/User/xxx/mysql_data:/var/lib/mysql \\ mysql:5.7 --innodb_use_native_aio=0 docker run -d -it --name tars_java \\ --link mysql \\ --env DBIP=mysql \\ --env DBPort=3306 \\ --env DBUser=root \\ --env DBPassword=password \\ -p 3000:3000 \\ -p 18600:18600 \\ -v C:/Users/xxx/tars_data:/data \\ tarscloud/tars:java 待容器启动完毕，此时可以在本地访问\nhttp://127.0.0.1:3000\n查看TARS的web管理界面了。\n注：如果你使用的mysql不是5.6的版本，可能需要调整docker run的参数\nJava 本地单元测试方法 参考 https://tarscloud.github.io/TarsDocs/dev/tarsjava/tarsspringboot-shi-yong-shuo-ming.html {.is-info}\n拷贝node生成的模板文件到本地（在服务器 tasnode/data/服务名/conf 目录下） 修改其中每个servant的启动ip和端口文本地ip端口 配置启动参数 -Dconfig=(模板路径) 通过ide启动MainClass ","date":"2021-09-02T16:00:00Z","image":"https://wuyoudexiao.github.io/p/study-tars/tars_hu875a888cf5d5e3780616d87f4a390bc1_55883_120x120_fill_box_smart1_3.png","permalink":"https://wuyoudexiao.github.io/p/study-tars/","title":"Tars学习记录"},{"content":"前后端分离的CAS单点登录 CAS登录原理 官方网址：https://apereo.github.io/cas/6.6.x/protocol/CAS-Protocol.html\n从官网上把流程图找到 我们简答梳理一下流程，主要分为两个步骤，未登录（包括失效的）和登录的\n第一次登录未流程 浏览器向应用发起请求，应用发现该请求未授权（无session或者过期） 应用响应一个重定向给浏览器，重定向去CAS登录页面 用户登录页面输入密码 CAS认证用户通过，写入TGC到cookie，带着Ticket重定向到应用 应用向CAS验证Ticket的有效性，有效就set Session并重定向到服务（去掉Ticket） 浏览器带着Session请求服务，服务校验Session 第二次登录流程 浏览器向应用发起请求，应用校验Session Session合法就正常执行并返回 第一次登录另一个应用 浏览器向应用发起请求，应用发现请求未授权 应用将浏览器携带TGT重定向去CAS登录页面 CAS校验TGT合法性，并重定向回应用（带着Ticket） 应用向CAS确认Ticket的合法性，合法就签发Session CAS登录存在的问题 一个域名下的前端页面往往非常多，如果Session在某一个页面访问的时候超时，需要重新登录，那么CAS服务发送重定向的时候不知道来源所以只能重定向到首页，会给用户带来较差的体验。\n解决办法 ","date":"2021-09-02T14:28:00Z","image":"https://wuyoudexiao.github.io/p/study-cas/cas_hu2d409dda071923d4643e2b22d9f0790a_56691_120x120_fill_box_smart1_3.png","permalink":"https://wuyoudexiao.github.io/p/study-cas/","title":"前后端分离的CAS单点登录"},{"content":"ElasticSearch学习记录 数据类型 基础类型 字符串 String : 高版本的ES已经停用 text : 当一个字段是要被全文搜索的使用text类型。设置text类型以后，字段内容会被分析，在生成倒排索引，字符串会被分析器分成一个一个词项。text类型的字段不用于排序，很少用于聚合。 keyword : 适用于索引结构化的字段。如果字段需要进行过滤、排序、聚合需要采用keyword字段。keyword类型的字段只能通过精确值搜索到。 日期 date类型，需要注意：\nElasticsearch采用UTC时区，与北京时间相差8小时，同步时需要注明时区。 默认格式是 strict_date_optional_time||epoch_millis 只接受年月日必须是4位、2位、2位表示，不足两位用0补齐的字符串日期或者long型数字的毫秒时间戳。 可以指定format使得取时间时是按照固定格式。 整数 在满足需求的情况下，尽可能选择范围小的数据类型。\n类型 取值范围 byte -128~127 short -32768~32767 integer -231~231-1 long -263~263-1 高级类型 数组 可以支持字符数组，整数数组，对象数组。不支持元素为多个数据类型！\n对象 JSON对象，包含嵌套的对象。\n嵌套 Nested类型允许独立的索引每一个对象，对性能的影响较大。\nIk分词 与 pinyin分词 导入字典 导入研究人员名称 导入停用词 自动化更新字典 算法（BM25）优化 用$D$代指计算文档，$Q$指的是用户输入的搜索关键词，将$Q$分词后得到若干词$q_i$，计算得到的分数为$score(D,Q)$如下。 $$ score(D,Q) = \\sum_{i=1}^n IDF(q_i) \\cdot \\frac{f(q_i,D)\\cdot(k_1+1)}{f(q_i,D)+k_1 \\cdot (1-b+b\\cdot \\frac{\\left\\vert D\\right\\vert}{avgdl})} $$\n在公式中有两个常数参数$b$和$k_1$。其中参数$b$的作用是调整文档长度对相关性影响的大小。$b$越大，文档长度的对相关性得分的影响越大，反之越小。参数$k_1$的作用是调节$q_i$增加时，得分增加的幅度。经过实践验证，通常的系统中选择$b = 0.75,k=2$可以获得较好的效果。\nQuery DSL 1. 采用multi_match匹配 最简单的匹配方式，获得的结果难以满足要求。\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;query\u0026#34;:{ \u0026#34;multi_match\u0026#34;:{ \u0026#34;query\u0026#34;: \u0026#34;search_text\u0026#34;, \u0026#34;fields\u0026#34;:[ \u0026#34;f1\u0026#34;,\u0026#34;f2\u0026#34; ] } } } 2. 采用bool查询 添加筛选的查询方式。提供must，should，must_not，filter四种方式组合。\nmust必须满足，非直接过滤，参与评分。 should在有must的情况下无需满足，无must的情况下必须满足至少一个。默认参与评分，可以选择最少满足个数与是否参与评分。 must_not与filter为过滤器，不参与评分。 1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;query\u0026#34;:{ \u0026#34;bool\u0026#34;:{ \u0026#34;should\u0026#34;:[ {\u0026#34;match\u0026#34;:{\u0026#34;f1\u0026#34;:\u0026#34;search_text\u0026#34;}}, {\u0026#34;match\u0026#34;:{\u0026#34;f2\u0026#34;:\u0026#34;search_text\u0026#34;}} ], \u0026#34;filter\u0026#34;:[ {\u0026#34;range\u0026#34;:{\u0026#34;date\u0026#34;:{\u0026#34;gte\u0026#34;:\u0026#34;2010-01-01\u0026#34;}}}, ] } } } 3. 采用match_phrase提高权重 解决搜索经常出现搜索结果和搜索关键词不是连续匹配的这个问题。match_phrase 要求必须命中所有分词，并且返回的文档命中的词也要按照查询短语的顺序，词的间距可以使用 slop 设置。同时使用 match 与 match_phrase 查询语句，这样相当于 match_pharse 提高了搜索短语顺序的权重，使得能够顺序匹配到的文档相关性评分更高。设置索引mappings时，给 tags 字段设置上 position_increment_gap （默认100），来增加数组元素之间的位置，此位置要超过查询所使用的 slop。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;query\u0026#34;:{ \u0026#34;bool\u0026#34;:{ \u0026#34;should\u0026#34;:[ {\u0026#34;match\u0026#34;:{\u0026#34;f1\u0026#34;:\u0026#34;search_text\u0026#34;}}, {\u0026#34;match_phrase\u0026#34;:{\u0026#34;f1\u0026#34;:{\u0026#34;query\u0026#34;:\u0026#34;search_text\u0026#34;,\u0026#34;slop\u0026#34;:5}}}, {\u0026#34;match\u0026#34;:{\u0026#34;f2\u0026#34;:\u0026#34;search_text\u0026#34;}} ], \u0026#34;filter\u0026#34;:[ {\u0026#34;range\u0026#34;:{\u0026#34;date\u0026#34;:{\u0026#34;gte\u0026#34;:\u0026#34;2010-01-01\u0026#34;}}}, ] } } } 4. 采用boost调整查询语句的权重 查询时可以用 boost 配置来增加权重。设置后，查询语句的得分等于默认得分乘以 boost。\n数据质量高的字段可以相应提高权重；\nmatch_phrase 语句的权重应该高于相应字段 match 查询的权重，因为文档中按顺序匹配的短语可能数量不会太多，但是查询关键词被分词后的词语将会很多，match的得分将会比较高，则 match 的得分将会冲淡 match_phrase 的影响；\n在 mappings 设置中，可以针对字段设置权重，查询时不用再针对字段使用 boost 设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;query\u0026#34;:{ \u0026#34;bool\u0026#34;:{ \u0026#34;should\u0026#34;:[ {\u0026#34;match\u0026#34;:{\u0026#34;f1\u0026#34;:\u0026#34;search_text\u0026#34;}}, {\u0026#34;match_phrase\u0026#34;:{\u0026#34;f1\u0026#34;:{\u0026#34;query\u0026#34;:\u0026#34;search_text\u0026#34;,\u0026#34;slop\u0026#34;:5,\u0026#34;boost\u0026#34;:10}}}, {\u0026#34;match\u0026#34;:{\u0026#34;f2\u0026#34;:\u0026#34;search_text\u0026#34;}} ], \u0026#34;filter\u0026#34;:[ {\u0026#34;range\u0026#34;:{\u0026#34;date\u0026#34;:{\u0026#34;gte\u0026#34;:\u0026#34;2010-01-01\u0026#34;}}}, ] } } } 5.采用function_score增加评分因素 为了增加实际项目中时间，对文档评分的影响往往比较复杂，不仅仅时简单的计算相关度，还需要根据字段对评分进行一定的计算。function_score可以解决以下问题。\n时间影响：距今越近的文档具有更高的评分； 收藏影响：收藏数量更多的文档具有更高的评分； 完整性影响：完整的文档比残缺的文档具有更高的评分； 推广影响：被推广的文档具有更高的评分； ······ 在数据搭建阶段我们就能确定这些因素的权重，并且和查询关键词没有什么关系。称之为静态评分，一般具有以下特点：\n稳定性：不要经常有大幅度的变动，如果大幅度变化会导致用户搜索相同的关键词过段时间出来的结果会不同； 连续性：相似静态评分的情况下，文档的相关的等其他因素可以充分发挥作用。 区分度：在连续稳定的情况下，应该有一定的区分度，也即分值的间隔应该合理。如果有 1000 份文档，在 1.0 分到 1.001 分之间，这其实是没有实际意义的，因为对文档排名的影响太少了。 在ES中有以下的方式实现这些因素对排名的影响：\nscript_score，这是最灵活的方式，可以自定义算法； weight，乘以一个权重数值； random_score，随机分数； field_value_factor，使用某个字段来影响总分数； decay fucntion，包括gauss、exp、linear三种衰减函数。 filed_value_factor 1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;query\u0026#34;:{ \u0026#34;function_score\u0026#34;:{ \u0026#34;field_value_factor\u0026#34;:{ \u0026#34;field\u0026#34;: \u0026#34;collection_num\u0026#34;, \u0026#34;factor\u0026#34;: 1, \u0026#34;modifier\u0026#34;: \u0026#34;log2p\u0026#34;, \u0026#34;missing\u0026#34;: 0 } } } } modifier支持的函数有：\nnone：$score^* = score \\cdot collectionNum$ log1p：$score^* = score \\cdot log(1 + factor \\cdot collectionNum)$ log2p：$score^* = score \\cdot log(2 + factor \\cdot collectionNum)$ ln : $score^* = score \\cdot ln(factor \\cdot collectionNum)$ ln1p : $score^* = score \\cdot ln(1 + factor \\cdot collectionNum)$ ln2p : $score^* = score \\cdot ln(2 + factor \\cdot collectionNum)$ square sqrt reciprocal 除了modifier还有boost_mode可以改变对评分影响的模式，默认的改变评分方式为乘积，如果将boost_mode设定为sum那么将大大弱化这些因素对结果的影响。最后还可以加上max_boost参数来限定最大的boost值。missing参数还可以用来降低残缺文档的评分，把 missing 设置为小于1的数值即可。\ndecay function 衰减函数可以实现平滑过渡，使距离某个点越近的文档分数越高，越远的分数越低。使用衰减函数很容易实现时间越近的文档得分就越高的场景。ES提供了三个衰减函数，我们先来看一下这三种衰减函数的差别。\nlinear，是两条线性函数，从直线和横轴相交处以外，评分都为0； exp，是指数函数，先剧烈的衰减，然后缓慢衰减； guass，高斯衰减是最常用的，先缓慢再剧烈再缓慢，scale相交的点附近衰减比较剧烈。 当我们想选取一定范围内的结果，或者一定范围内的结果比较重要时，例如某个时间、地域（圆形）、价格范围内，都可以使用高斯衰减函数。高斯衰减函数有4个参数可以设置\norigin：中心点，或字段可能的最佳值，落在原点 origin 上的文档评分 _score 为满分 1.0 ； scale：衰减率，即一个文档从原点 origin 下落时，评分 _score 改变的速度； decay：从原点 origin 衰减到 scale 所得的评分 _score ，默认值为 0.5 ； offset：以原点 origin 为中心点，为其设置一个非零的偏移量 offset 覆盖一个范围，而不只是单个原点。在范围 -offset \u0026lt;= origin \u0026lt;= +offset 内的所有评分 _score 都是 1.0 。 假定搜索引擎中三年内的文档会比较重要，三年之前的信息价值降低，就可以选择 origin 为今天，scale 为三年，decay 为 0.5，offset 为三个月。\n6.采用script_sort进行排序 基于脚本的排序 允许根据自定义脚本进行排序，下面是一个示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 GET /_search { \u0026#34;query\u0026#34; : { \u0026#34;term\u0026#34; : { \u0026#34;user\u0026#34; : \u0026#34;kimchy\u0026#34; } }, \u0026#34;sort\u0026#34; : { \u0026#34;_script\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;number\u0026#34;, \u0026#34;script\u0026#34; : { \u0026#34;lang\u0026#34;: \u0026#34;painless\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;doc[\u0026#39;field_name\u0026#39;].value * params.factor\u0026#34;, \u0026#34;params\u0026#34; : { \u0026#34;factor\u0026#34; : 1.1 } }, \u0026#34;order\u0026#34; : \u0026#34;asc\u0026#34; } } } 如何使用脚本 1 2 3 4 5 \u0026#34;script\u0026#34;: { \u0026#34;lang\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;source\u0026#34; | \u0026#34;id\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;params\u0026#34;: { ... } } \u0026ldquo;lang\u0026rdquo;：编写脚本所用的语言，默认为painless。 \u0026ldquo;source\u0026rdquo; | \u0026ldquo;id\u0026rdquo;：可以指定为内联脚本或存储脚本的脚本本身。 \u0026ldquo;params\u0026rdquo;：应传递到脚本中的任何命名参数。\n人员搜索排序脚本 当前ES中存储的自定义人员排序脚本，根据人员关键词权重进行排序。\n","date":"2021-06-02T14:28:00Z","image":"https://wuyoudexiao.github.io/p/study-es/es-%E8%A1%B0%E5%87%8F%E5%87%BD%E6%95%B0_hu1c76feb9b2706ad14d03897c9357b434_29245_120x120_fill_q75_box_smart1.jpg","permalink":"https://wuyoudexiao.github.io/p/study-es/","title":"ElasticSearch学习记录"},{"content":"博客的起点 Look to those who walked before to lead those who walk after\n一直很喜欢横渠四句，尤其是其中的为往圣继绝学，可惜我学的并不是什么高大上的东西，或许没什么意思，一路走来看了不知道多少的优秀文章，如果我写的心得体会能帮助到其他人，也是一种幸福吧。\n","date":"2020-10-06T00:00:00Z","image":"https://wuyoudexiao.github.io/p/hello-world/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://wuyoudexiao.github.io/p/hello-world/","title":"Hello World"}]